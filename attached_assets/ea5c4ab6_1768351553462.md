# CODE TASK 1.1: Weighted Partner Rotation Engine
**Task ID:** 1.1  
**Status:** READY FOR EXECUTION  
**Estimated Time:** 2 hours (code + tests)  
**Complexity:** Medium  

---

## üìã REQUIREMENTS SUMMARY

### What It Does
Implements a **weighted randomizer** that ensures higher-bidding partners get more visibility in search results. A partner bidding $45/click should appear ~3x more often than a partner bidding $15/click.

### Why It's Critical
- **Revenue model depends on it** - Partners pay based on visibility
- **Must be fair** - Weight distribution prevents monopolies
- **Algorithm must be correct** - Off-by-one errors break economics

### Source Threads
- "Name Your Price" (bidding model)
- "Visibility Meter" (bid comparison)
- "Bid Rotation Logic" (gap analysis)

### Key Requirements
```
Input:  [Partner A ($15), Partner B ($45), Partner C ($30)]
Output: [Partner B, Partner A, Partner C] (top 3 by weighted selection)

Weight formula: weight = bid / minimumViableBid
Partner A: $15 / $12 = 1.0 weight
Partner B: $45 / $12 = 3.75 weight  
Partner C: $30 / $12 = 2.5 weight

Over 100 iterations:
- Partner A appears ~11% of the time (1.0 / 9.25)
- Partner B appears ~41% of the time (3.75 / 9.25)
- Partner C appears ~27% of the time (2.5 / 9.25)
```

---

## üèóÔ∏è ARCHITECTURE

### Input
```javascript
{
  partners: [
    { id: "P1", name: "Austin Roofing", bid: 15, weight: 1.0 },
    { id: "P2", name: "Pro Restoration", bid: 45, weight: 3.75 },
    { id: "P3", name: "Contractor Network", bid: 30, weight: 2.5 }
  ],
  count: 3  // How many partners to return
}
```

### Output
```javascript
[
  { id: "P2", name: "Pro Restoration", bid: 45, weight: 3.75 },
  { id: "P3", name: "Contractor Network", bid: 30, weight: 2.5 },
  { id: "P1", name: "Austin Roofing", bid: 15, weight: 1.0 }
]
// Returned in weighted random order (no duplicates)
```

### Dependencies
- None (zero external dependencies)
- Pure JavaScript
- Works in Node.js and browser

### Related Tasks
- Task 1.4: Server endpoint that uses this
- Task 2.1: Partner dashboard that displays results
- Task 3.1: Database that stores partner weights

---

## üíª PRODUCTION-READY CODE

### File: `src/utils/adRotation.js`

```javascript
/**
 * MAXCLAIM AD ROTATION ENGINE
 * Implements weighted random selection for partner visibility
 * 
 * Ensures fair distribution:
 * - Partner bidding $45 ‚Üí weight 3.75 ‚Üí appears ~41% of time
 * - Partner bidding $15 ‚Üí weight 1.0 ‚Üí appears ~11% of time
 * 
 * @module adRotation
 */

/**
 * Weighted Random Selector for Ad Rotation
 * 
 * Algorithm:
 * 1. Calculate total weight of all partners
 * 2. Generate random number between 0 and totalWeight
 * 3. Iterate through partners, subtracting weight from random
 * 4. When random <= 0, return that partner
 * 5. Remove selected partner and repeat for count
 * 
 * Time Complexity: O(n * count)
 * Space Complexity: O(count)
 * 
 * @param {Array<Object>} partners - Array of partner objects with 'weight' property
 *        Example: [{ id: 1, weight: 1.0 }, { id: 2, weight: 3.0 }]
 * @param {number} count - Number of partners to return (default: 3)
 * @returns {Array<Object>} Selected partners in weighted random order
 * 
 * @example
 * const partners = [
 *   { id: 1, name: 'Austin Roofing', bid: 15, weight: 1.0 },
 *   { id: 2, name: 'Pro Restoration', bid: 45, weight: 3.75 }
 * ];
 * const selected = getWeightedPartners(partners, 3);
 * // Returns approximately [partner2, partner2, partner1]
 * // (partner2 selected ~3.75x more often)
 */
export function getWeightedPartners(partners, count = 3) {
  // Input validation
  if (!partners || !Array.isArray(partners)) {
    console.error('[adRotation] Invalid partners array');
    return [];
  }

  if (partners.length === 0) {
    console.warn('[adRotation] Empty partners array');
    return [];
  }

  // Edge case: fewer partners than requested
  if (partners.length <= count) {
    console.warn(
      `[adRotation] Requested ${count} partners but only ${partners.length} available`
    );
    return [...partners];
  }

  const selected = [];
  const pool = [...partners]; // Create mutable copy

  // Select 'count' partners using weighted randomization
  while (selected.length < count && pool.length > 0) {
    // Step 1: Calculate total weight of remaining pool
    const totalWeight = pool.reduce((sum, p) => {
      const weight = p.weight || 1;
      if (typeof weight !== 'number' || weight <= 0) {
        console.warn(
          `[adRotation] Invalid weight for partner ${p.id}: ${weight}. Using 1.0`
        );
        return sum + 1;
      }
      return sum + weight;
    }, 0);

    // Step 2: Generate random threshold
    let random = Math.random() * totalWeight;

    // Step 3: Find partner that crosses the threshold
    for (let i = 0; i < pool.length; i++) {
      const weight = pool[i].weight || 1;
      random -= weight;

      // Step 4: Partner selected
      if (random <= 0) {
        selected.push(pool[i]);
        // Step 5: Remove to prevent duplicates
        pool.splice(i, 1);
        break;
      }
    }
  }

  return selected;
}

/**
 * Calculate weight from bid amount
 * 
 * Formula: weight = bid / minimumViableBid
 * 
 * @param {number} bid - Partner's CPC bid
 * @param {number} minimumViableBid - Platform minimum (default: $12)
 * @returns {number} Weight factor (1.0 or higher)
 * 
 * @example
 * calculateWeight(15, 12) ‚Üí 1.25
 * calculateWeight(45, 12) ‚Üí 3.75
 * calculateWeight(30, 12) ‚Üí 2.5
 */
export function calculateWeight(bid, minimumViableBid = 12) {
  if (typeof bid !== 'number' || bid <= 0) {
    console.error('[adRotation] Invalid bid amount:', bid);
    return 1;
  }

  if (typeof minimumViableBid !== 'number' || minimumViableBid <= 0) {
    console.error('[adRotation] Invalid minimum viable bid:', minimumViableBid);
    return 1;
  }

  const weight = bid / minimumViableBid;

  // Sanity check: cap weight at 10x to prevent extreme values
  if (weight > 10) {
    console.warn(
      `[adRotation] Weight ${weight} exceeds maximum (10x). Capping at 10.`
    );
    return 10;
  }

  return weight;
}

/**
 * Apply weights to partners based on bids
 * 
 * Enriches partner objects with calculated weights
 * 
 * @param {Array<Object>} partners - Partner objects with 'bid' property
 * @param {number} minimumViableBid - Platform minimum (default: $12)
 * @returns {Array<Object>} Partners with added/updated 'weight' property
 * 
 * @example
 * const partners = [
 *   { id: 1, bid: 15 },
 *   { id: 2, bid: 45 }
 * ];
 * const weighted = applyWeights(partners);
 * // Returns [
 * //   { id: 1, bid: 15, weight: 1.25 },
 * //   { id: 2, bid: 45, weight: 3.75 }
 * // ]
 */
export function applyWeights(partners, minimumViableBid = 12) {
  if (!Array.isArray(partners)) {
    return [];
  }

  return partners.map(partner => ({
    ...partner,
    weight: calculateWeight(partner.bid, minimumViableBid)
  }));
}

/**
 * Test distribution of weighted selection
 * 
 * Runs multiple iterations to verify weight distribution
 * Useful for testing and debugging
 * 
 * @param {Array<Object>} partners - Partner objects
 * @param {number} iterations - How many selections to run (default: 1000)
 * @returns {Object} Statistics showing actual distribution
 * 
 * @example
 * const stats = testDistribution(partners, 1000);
 * console.log(stats);
 * // Output:
 * // {
 * //   partner1: { count: 110, percentage: 11.0 },
 * //   partner2: { count: 410, percentage: 41.0 },
 * //   partner3: { count: 270, percentage: 27.0 }
 * // }
 */
export function testDistribution(partners, iterations = 1000) {
  if (!Array.isArray(partners) || partners.length === 0) {
    return {};
  }

  const counts = {};
  
  // Initialize count tracker
  partners.forEach(p => {
    counts[p.id] = 0;
  });

  // Run weighted selection 'iterations' times
  for (let i = 0; i < iterations; i++) {
    const selected = getWeightedPartners(partners, 1);
    if (selected.length > 0) {
      counts[selected[0].id]++;
    }
  }

  // Convert to percentages
  const stats = {};
  Object.entries(counts).forEach(([id, count]) => {
    stats[id] = {
      count,
      percentage: Number(((count / iterations) * 100).toFixed(2))
    };
  });

  return stats;
}

/**
 * Verify weight calculations match expected formula
 * 
 * @returns {boolean} True if all tests pass
 */
export function runSelfTests() {
  let passed = 0;
  let failed = 0;

  // Test 1: Basic weight calculation
  const weight1 = calculateWeight(15, 12);
  if (Math.abs(weight1 - 1.25) < 0.01) {
    passed++;
    console.log('‚úì Test 1: Weight calculation correct (15/12 = 1.25)');
  } else {
    failed++;
    console.error('‚úó Test 1: Weight calculation failed');
  }

  // Test 2: Higher bid = higher weight
  const weight2a = calculateWeight(15, 12);
  const weight2b = calculateWeight(45, 12);
  if (weight2b > weight2a) {
    passed++;
    console.log('‚úì Test 2: Higher bid results in higher weight');
  } else {
    failed++;
    console.error('‚úó Test 2: Higher bid should result in higher weight');
  }

  // Test 3: Weighted selection returns correct count
  const testPartners = [
    { id: 1, weight: 1.0 },
    { id: 2, weight: 2.0 },
    { id: 3, weight: 3.0 }
  ];
  const selected = getWeightedPartners(testPartners, 2);
  if (selected.length === 2) {
    passed++;
    console.log('‚úì Test 3: Selection returns correct count');
  } else {
    failed++;
    console.error('‚úó Test 3: Selection returned wrong count');
  }

  // Test 4: No duplicates in selection
  const selected4 = getWeightedPartners(testPartners, 3);
  const ids = selected4.map(p => p.id);
  if (new Set(ids).size === ids.length) {
    passed++;
    console.log('‚úì Test 4: No duplicate selections');
  } else {
    failed++;
    console.error('‚úó Test 4: Found duplicate selections');
  }

  // Test 5: Empty array handling
  const empty = getWeightedPartners([], 3);
  if (empty.length === 0) {
    passed++;
    console.log('‚úì Test 5: Empty array handled correctly');
  } else {
    failed++;
    console.error('‚úó Test 5: Empty array not handled');
  }

  console.log(`\n[adRotation] Tests: ${passed} passed, ${failed} failed`);
  return failed === 0;
}
```

---

## üìç USAGE GUIDE

### Import in server.js

```javascript
// At top of server.js
import { 
  getWeightedPartners, 
  calculateWeight, 
  applyWeights 
} from './src/utils/adRotation.js';
```

### Create API Endpoint

```javascript
// In server.js routes section
app.get('/api/partners/:trade', (req, res) => {
  try {
    const { trade } = req.params;
    const { zip, carrier } = req.query;

    // Filter candidates by trade and location
    let candidates = PARTNERS.promo.filter(p => 
      p.category.toLowerCase().includes(trade.toLowerCase()) &&
      (!zip || p.serviceArea.includes(zip))
    );

    if (candidates.length === 0) {
      return res.status(404).json({ 
        error: 'No partners found for this criteria',
        trade,
        zip 
      });
    }

    // Apply weights if not already calculated
    if (!candidates[0].weight) {
      candidates = applyWeights(candidates, 12); // $12 MVB
    }

    // Get top 3 using weighted rotation
    const topPartners = getWeightedPartners(candidates, 3);

    res.json({
      success: true,
      trade,
      zip,
      carrier,
      partners: topPartners,
      totalCandidates: candidates.length,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('[/api/partners/:trade]', error);
    res.status(500).json({ 
      error: 'Failed to fetch partners',
      message: error.message 
    });
  }
});
```

### Frontend Integration

```javascript
// In your React component (e.g., AuditResults.jsx)
async function fetchPartners(trade, zip, carrier) {
  try {
    const response = await fetch(
      `/api/partners/${trade}?zip=${zip}&carrier=${carrier}`
    );
    const data = await response.json();
    
    if (data.success) {
      setTopPartners(data.partners); // [P1, P2, P3]
      return data.partners;
    }
  } catch (error) {
    console.error('Failed to fetch partners:', error);
  }
}

// Render top 3 partners
{topPartners.map((partner, index) => (
  <PartnerCard 
    key={partner.id}
    partner={partner}
    rank={index + 1}
  />
))}
```

---

## üß™ TESTING

### Unit Tests

Create file: `tests/adRotation.test.js`

```javascript
import {
  getWeightedPartners,
  calculateWeight,
  applyWeights,
  testDistribution
} from '../src/utils/adRotation.js';

describe('adRotation - Weighted Partner Selection', () => {
  
  describe('calculateWeight()', () => {
    test('should calculate weight correctly', () => {
      expect(calculateWeight(15, 12)).toBeCloseTo(1.25, 2);
      expect(calculateWeight(45, 12)).toBeCloseTo(3.75, 2);
      expect(calculateWeight(12, 12)).toBe(1);
    });

    test('should handle invalid inputs', () => {
      expect(calculateWeight(0, 12)).toBe(1);
      expect(calculateWeight(-5, 12)).toBe(1);
      expect(calculateWeight('invalid', 12)).toBe(1);
    });

    test('should cap extreme weights at 10x', () => {
      expect(calculateWeight(500, 12)).toBe(10);
    });
  });

  describe('applyWeights()', () => {
    test('should add weight property to partners', () => {
      const partners = [
        { id: 1, bid: 15 },
        { id: 2, bid: 45 }
      ];
      const result = applyWeights(partners);
      
      expect(result[0]).toHaveProperty('weight');
      expect(result[0].weight).toBeCloseTo(1.25, 2);
      expect(result[1].weight).toBeCloseTo(3.75, 2);
    });
  });

  describe('getWeightedPartners()', () => {
    const partners = [
      { id: 1, name: 'Partner A', weight: 1.0 },
      { id: 2, name: 'Partner B', weight: 3.75 },
      { id: 3, name: 'Partner C', weight: 2.5 }
    ];

    test('should return requested count', () => {
      const result = getWeightedPartners(partners, 3);
      expect(result).toHaveLength(3);
    });

    test('should return fewer if not enough partners', () => {
      const result = getWeightedPartners(partners, 5);
      expect(result.length).toBeLessThanOrEqual(partners.length);
    });

    test('should not return duplicates', () => {
      const result = getWeightedPartners(partners, 3);
      const ids = result.map(p => p.id);
      expect(new Set(ids).size).toBe(ids.length);
    });

    test('should handle empty array', () => {
      const result = getWeightedPartners([], 3);
      expect(result).toEqual([]);
    });

    test('should favor higher weight partners', () => {
      // Run distribution test
      const stats = testDistribution(partners, 10000);
      
      // Partner B (weight 3.75) should appear most
      expect(stats[2].percentage).toBeGreaterThan(stats[1].percentage);
      expect(stats[2].percentage).toBeGreaterThan(stats[3].percentage);
    });
  });

  describe('testDistribution()', () => {
    test('should return statistics for each partner', () => {
      const partners = [
        { id: 1, weight: 1.0 },
        { id: 2, weight: 3.0 }
      ];
      const stats = testDistribution(partners, 1000);
      
      expect(stats[1]).toHaveProperty('count');
      expect(stats[1]).toHaveProperty('percentage');
      expect(stats[2]).toHaveProperty('count');
      expect(stats[2]).toHaveProperty('percentage');
    });
  });
});
```

### Manual Testing

```bash
# Run unit tests
npm test -- adRotation.test.js

# Test in console
node -e "
import('./src/utils/adRotation.js').then(m => {
  const partners = [
    { id: 1, name: 'A', weight: 1 },
    { id: 2, name: 'B', weight: 3 },
    { id: 3, name: 'C', weight: 2 }
  ];
  console.log('Distribution test (1000 iterations):');
  console.log(m.testDistribution(partners, 1000));
  
  console.log('\\nRun self tests:');
  m.runSelfTests();
});
"

# Test API endpoint
curl "http://localhost:3000/api/partners/Roofing?zip=78701&carrier=StateFarm"
```

---

## ‚úÖ DEPLOYMENT CHECKLIST

- [ ] Code copied to `src/utils/adRotation.js`
- [ ] No console.log() except warnings
- [ ] All JSDoc comments complete
- [ ] Unit tests created and passing
- [ ] Self-tests run successfully
- [ ] API endpoint wired in server.js
- [ ] Error handling for invalid inputs
- [ ] Tested with real partner data
- [ ] Performance acceptable (<50ms per request)
- [ ] Logged all warnings to monitoring system

---

## üîó INTEGRATION POINTS

**Depends On:** None (zero dependencies)

**Feeds Into:**
- Task 1.4: `/api/partners/:trade` endpoint
- Task 2.1: PartnerDashboard component
- Task 2.3: AuditResults display

**Database:** PARTNERS.promo array (or database query)

**Frontend:** React component fetches `/api/partners/:trade`

---

## üìä SUCCESS CRITERIA

‚úÖ Weight distribution matches expected percentages (within 2%)  
‚úÖ No partners appear twice in single selection  
‚úÖ API response time <100ms even with 100+ partners  
‚úÖ All edge cases handled gracefully  
‚úÖ Code passes security review (no injection vulnerabilities)  
‚úÖ Ready for production deployment  

---

## üöÄ NEXT TASK

After Task 1.1 is complete:
‚Üí **Task 1.2: Carrier Intelligence Engine** (carrierIntel.js)

---

**Status:** READY TO CODE  
**Confidence:** 95%  
**Estimated Completion:** 2 hours  

