# MaxClaim on ReplitCore - Redundancy & Failover Architecture
**Version 3.1 | January 13, 2026**

---

## CRITICAL PRINCIPLE

**Any code/service/feature discrepancy or contradiction in MaxClaim is INTENTIONALLY DOCUMENTED as "optional redundancy"** — meaning there are:

1. **Primary** implementations (required, always-on)
2. **Backup/Fallback** implementations (optional, only activated on failure)
3. **Feature toggles** (deployed but conditionally activated)

This doc explains the architecture to Replit and ensures the platform understands redundancy vs. conflicts.

---

## ARCHITECTURE LAYERS (ReplitCore)

```
APPLICATION LAYER (MaxClaim v3.1)
├─ Primary Services (Required, always-on)
├─ Fallback Services (Optional, activated on failure)
└─ Feature Toggles (Deployed, conditionally enabled)
    ↓
REPLIT CORE RUNTIME
├─ Container orchestration
├─ Environment management
├─ Health monitoring
└─ Auto-failover triggers
    ↓
INFRASTRUCTURE (Azure Backend)
├─ PostgreSQL (primary DB)
├─ Redis (cache/session)
├─ Blob Storage (file archive)
└─ Monitor (Prometheus/Grafana)
```

---

## SERVICE REDUNDANCY MATRIX

### Category 1: CLAIM PROCESSING

#### Primary: AI-Powered Audit (LangChain + OpenAI)

```javascript
// services/claimAudit/primaryAuditEngine.ts
Primary: LangChain orchestration → OpenAI API
├─ Real-time LLM analysis
├─ Complex reasoning chains
├─ Context-aware pricing
└─ Carrier intelligence integration

Cost: ~$0.10–$0.30 per claim
Latency: 3–8 seconds
Reliability: Depends on OpenAI API health
```

#### Fallback: Rule-Based Audit (Offline, Deterministic)

```javascript
// services/claimAudit/fallbackAuditEngine.ts
Fallback: Predefined rules + lookup tables
├─ Fuzzy-match against price database
├─ Deterministic severity flags
├─ No LLM required
└─ 100% available offline

Cost: $0 (compute only)
Latency: <100ms
Reliability: 99.99% (no external API calls)

TRIGGER: OpenAI API fails, latency > 10s, or rate-limit hit
```

**How Replit Knows:**
```json
{
  "service": "claim-audit",
  "primary": {
    "type": "ai-llm",
    "engine": "langchain-openai",
    "provider": "external-api",
    "required": true,
    "failoverBehavior": "switch-to-fallback"
  },
  "fallback": {
    "type": "rule-engine",
    "engine": "fuzzyMatch-ruleset",
    "provider": "local-compute",
    "required": false,
    "activateOn": "primary-failure"
  },
  "redundancy": "optional-backup"
}
```

---

### Category 2: DOCUMENT PARSING (OCR)

#### Primary: PaddleOCR (GPU, Fast)

```javascript
// services/ocr/primaryOcrEngine.ts
Primary: PaddleOCR (Paddle Deep Learning)
├─ GPU-accelerated (fast processing)
├─ 97%+ accuracy on claim documents
├─ Supports PDF + image formats
└─ Runs on Replit container

Cost: $0 (open-source)
Latency: 2–5 seconds per document
Reliability: Dependent on system resources
```

#### Fallback 1: Tesseract.js (CPU, Slower)

```javascript
// services/ocr/fallbackOcrEngine1.ts
Fallback 1: Tesseract.js (JavaScript CPU)
├─ No GPU required (pure CPU)
├─ 85–90% accuracy (lower than PaddleOCR)
├─ Works on any system
└─ Always available (no dependencies)

Cost: $0 (open-source)
Latency: 8–15 seconds per document
Reliability: 99%+ (no external calls, CPU-based)

TRIGGER: PaddleOCR crashes, GPU unavailable, or latency > 10s
```

#### Fallback 2: Manual Data Entry (Human)

```javascript
// services/ocr/fallbackOcrEngine2.ts
Fallback 2: User-Initiated Manual Entry
├─ Guided form for line-by-line input
├─ Auto-suggest pricing from database
├─ No parsing required
└─ User types directly into structured form

Cost: $0 (user time)
Latency: N/A (user-dependent)
Reliability: 100% (always available)

TRIGGER: Both OCR engines fail, or user prefers manual entry
```

**How Replit Knows:**
```json
{
  "service": "ocr-parsing",
  "primary": {
    "type": "paddle-ocr",
    "resources": "gpu-accelerated",
    "failoverBehavior": "try-next-fallback"
  },
  "fallback_chain": [
    {
      "priority": 1,
      "type": "tesseract-js",
      "resources": "cpu-only",
      "activateOn": "primary-failure-or-timeout"
    },
    {
      "priority": 2,
      "type": "manual-entry-form",
      "resources": "user-input",
      "activateOn": "all-ocr-engines-fail"
    }
  ],
  "redundancy": "cascading-fallback-chain"
}
```

---

### Category 3: PARTNER LEAD ROUTING

#### Primary: Weighted Geo-Algorithm (Real-Time)

```javascript
// services/leadRouting/primaryRouter.ts
Primary: Live weighted rotation
├─ Real-time contractor ranking
├─ Dynamic geo-weighting
├─ Budget cap enforcement
├─ Live database queries

Cost: <$0.001 per route
Latency: 50–200ms
Reliability: Depends on Redis + PostgreSQL
```

#### Fallback: Static Cached Snapshot

```javascript
// services/leadRouting/fallbackRouter.ts
Fallback: Pre-computed contractor rankings
├─ Updated hourly from primary algorithm
├─ Cached in Redis (fast retrieval)
├─ No real-time weighting
├─ Simpler, deterministic selection

Cost: $0 (cache hit)
Latency: <10ms
Reliability: 99%+ (local cache)

TRIGGER: Database unavailable or routing latency > 500ms
```

**How Replit Knows:**
```json
{
  "service": "lead-routing",
  "primary": {
    "type": "weighted-algorithm",
    "dataSource": "live-database",
    "performance": "200ms-latency",
    "required": true
  },
  "fallback": {
    "type": "cached-snapshot",
    "dataSource": "redis-cache",
    "performance": "10ms-latency",
    "staleness": "up-to-1-hour",
    "activateOn": "primary-database-unavailable"
  },
  "redundancy": "cache-fallback"
}
```

---

### Category 4: PAYMENT PROCESSING

#### Primary: Stripe (Live)

```javascript
// services/payments/primaryPaymentEngine.ts
Primary: Stripe API (live transactions)
├─ Real-time payment authorization
├─ Card processing
├─ Webhook-driven updates
├─ Full Stripe dashboard integration

Cost: 2.9% + $0.30 per transaction
Latency: 1–5 seconds
Reliability: Depends on Stripe API
```

#### Fallback: Local Queuing + Retry

```javascript
// services/payments/fallbackPaymentEngine.ts
Fallback: Local transaction queue
├─ Queue failed payments locally (PostgreSQL)
├─ Retry with exponential backoff
├─ Manual retry dashboard for ops
├─ Full audit trail of all attempts

Cost: $0 (local compute)
Latency: Retry every 5/10/30/60 minutes
Reliability: 100% (queue persists)

TRIGGER: Stripe API fails, timeout, or network error
```

**How Replit Knows:**
```json
{
  "service": "payments",
  "primary": {
    "type": "stripe-api",
    "provider": "external",
    "failoverBehavior": "queue-locally-and-retry"
  },
  "fallback": {
    "type": "local-transaction-queue",
    "storage": "postgresql",
    "retryPolicy": "exponential-backoff",
    "maxRetries": "unlimited-until-success",
    "activateOn": "stripe-unavailable"
  },
  "redundancy": "queued-retry"
}
```

---

### Category 5: AI/LLM SERVICES

#### Primary: OpenAI API (GPT-4)

```typescript
// services/ai/primaryLLM.ts
Primary: OpenAI API
├─ GPT-4 or GPT-3.5-turbo
├─ Complex reasoning
├─ Fine-tuned prompts
└─ Rate-limited ($0.10–$0.30 per claim)

Cost: API-based
Latency: 3–8 seconds
Reliability: 99.5% SLA
```

#### Fallback 1: LocalAI (Self-Hosted)

```typescript
// services/ai/fallbackLLM1.ts
Fallback 1: LocalAI (Mistral 7B or Llama 2)
├─ Self-hosted LLM
├─ Runs in Docker container
├─ Lower quality than GPT-4
├─ No API costs

Cost: $0 (compute only)
Latency: 5–15 seconds (CPU-dependent)
Reliability: 99%+ (local)

TRIGGER: OpenAI rate-limited, latency >15s, or API key expired
```

#### Fallback 2: Rule-Based Extraction

```typescript
// services/ai/fallbackLLM2.ts
Fallback 2: Regex + Rule-Based
├─ Deterministic pattern matching
├─ No ML required
├─ Fast and reliable
├─ Lower accuracy, but functional

Cost: $0
Latency: <100ms
Reliability: 100%

TRIGGER: Both LLM options fail
```

**How Replit Knows:**
```json
{
  "service": "ai-reasoning",
  "primary": {
    "type": "openai-gpt4",
    "provider": "external-api",
    "falloverBehavior": "cascade-fallbacks"
  },
  "fallback_chain": [
    {
      "priority": 1,
      "type": "local-llm",
      "model": "mistral-7b",
      "provider": "docker-container",
      "activateOn": "openai-api-failure"
    },
    {
      "priority": 2,
      "type": "rule-based-extraction",
      "provider": "local-compute",
      "activateOn": "all-llm-unavailable"
    }
  ],
  "redundancy": "cascading-llm-fallback"
}
```

---

### Category 6: AUTHENTICATION

#### Primary: Clerk (Hosted Auth)

```typescript
// services/auth/primaryAuth.ts
Primary: Clerk Authentication
├─ Managed user accounts
├─ OAuth integrations
├─ Session management
└─ Real-time user sync

Cost: Clerk SaaS pricing
Latency: 100–500ms
Reliability: 99.9% SLA
```

#### Fallback: JWT + Local Session

```typescript
// services/auth/fallbackAuth.ts
Fallback: Self-managed JWT
├─ Sign sessions locally (no Clerk)
├─ Store sessions in PostgreSQL
├─ Validate JWT on every request
├─ No external auth service needed

Cost: $0 (local compute)
Latency: <10ms
Reliability: 99%+ (local database)

TRIGGER: Clerk API unavailable or timeouts
```

**How Replit Knows:**
```json
{
  "service": "authentication",
  "primary": {
    "type": "clerk-hosted",
    "provider": "external",
    "falloverBehavior": "switch-to-jwt"
  },
  "fallback": {
    "type": "jwt-local",
    "provider": "local-compute",
    "storage": "postgresql",
    "activateOn": "clerk-unavailable"
  },
  "redundancy": "auth-provider-swap"
}
```

---

## FEATURE TOGGLES (Deployed but Conditionally Enabled)

### Toggle 1: Advanced Analytics (Optional Feature)

```typescript
// features/analytics/advancedAnalytics.ts
FEATURE: Advanced Analytics Dashboard
├─ Deployed: Yes (code exists in repo)
├─ Default Status: DISABLED
├─ Activation Conditions:
│  ├─ User has "analytics" plan
│  ├─ Replit has Grafana running
│  └─ PostgreSQL has 30+ days of data
└─ Fallback: Basic stats (simple queries)

// Toggle code
const analyticsEnabled = 
  user.plan.includes('analytics') && 
  services.grafana.healthy() && 
  database.hasMinimumHistoricalData();

if (analyticsEnabled) {
  loadAdvancedDashboard();
} else {
  loadBasicStatsPage();
}
```

**How Replit Knows:**
```json
{
  "feature": "advanced-analytics",
  "deployed": true,
  "default_status": "disabled",
  "activation_conditions": {
    "user_plan": "analytics",
    "service_health": "grafana-required",
    "data_requirements": "30-days-history"
  },
  "redundancy": "feature-toggle"
}
```

---

### Toggle 2: Multi-Agent Swarm (Optional Feature)

```typescript
// features/agents/multiAgentSwarm.ts
FEATURE: Multi-Agent Advocacy Swarm (LangGraph)
├─ Deployed: Yes (complex, resource-intensive)
├─ Default Status: DISABLED (expensive)
├─ Activation Conditions:
│  ├─ Enterprise customers only
│  ├─ Opt-in per claim
│  └─ Credits > $100
└─ Fallback: Single-agent processing

// Toggle code
const multiAgentEnabled = 
  user.tier === 'enterprise' && 
  user.hasOptedInForSwarm &&
  user.credits > 100;

if (multiAgentEnabled) {
  orchestrateMultiAgentSwarm(claim);
} else {
  orchestrateSingleAgent(claim);
}
```

**How Replit Knows:**
```json
{
  "feature": "multi-agent-swarm",
  "deployed": true,
  "default_status": "disabled",
  "cost": "high-compute",
  "activation_conditions": {
    "tier": "enterprise-only",
    "user_action": "opt-in",
    "credits_required": 100
  },
  "redundancy": "optional-premium-feature"
}
```

---

### Toggle 3: Real-Time Lead Notifications (Optional)

```typescript
// features/realtime/leadNotifications.ts
FEATURE: Real-Time Lead Notifications (WebSocket)
├─ Deployed: Yes
├─ Default Status: DISABLED (requires WebSocket connection)
├─ Activation Conditions:
│  ├─ Browser supports WebSocket
│  ├─ Redis connection healthy
│  └─ User subscribed to notifications
└─ Fallback: 10-second polling

// Toggle code
const realtimeEnabled = 
  browser.supportsWebSocket && 
  redis.healthy &&
  user.notificationsEnabled;

if (realtimeEnabled) {
  setupWebSocketConnection();
} else {
  setupPollingFallback(10000); // 10 sec
}
```

**How Replit Knows:**
```json
{
  "feature": "realtime-notifications",
  "deployed": true,
  "default_status": "disabled",
  "fallback_latency": "10-seconds",
  "activation_conditions": {
    "browser_capability": "websocket",
    "service_health": "redis-required",
    "user_preference": "notifications-enabled"
  },
  "redundancy": "polling-fallback"
}
```

---

## CONTRADICTION RESOLUTION FRAMEWORK

### Scenario 1: Two Payment Processors Exist

**Contradiction:** Code has both Stripe AND local payment queue.

**Resolution:**
```json
{
  "contradiction": "multiple-payment-processors",
  "explanation": "optional-redundancy",
  "primary": "stripe-api",
  "fallback": "local-queue",
  "behavior": {
    "normal_operation": "stripe-only",
    "stripe_fails": "switch-to-local-queue",
    "both_available": "use-stripe-with-queue-backup",
    "queue_retry": "exponential-backoff"
  }
}
```

### Scenario 2: Two OCR Engines Exist

**Contradiction:** Code has PaddleOCR, Tesseract, AND manual entry.

**Resolution:**
```json
{
  "contradiction": "multiple-ocr-engines",
  "explanation": "cascading-fallback-chain",
  "priority_order": [
    "paddle-ocr-gpu-fast",
    "tesseract-js-cpu-slower",
    "manual-entry-form-slowest"
  ],
  "activation_logic": {
    "step_1": "try_paddleocr(timeout=5s)",
    "step_2": "if_fails_try_tesseract(timeout=10s)",
    "step_3": "if_fails_offer_manual_entry",
    "result": "claim_processed_one_way_or_another"
  }
}
```

### Scenario 3: Two Routing Algorithms Exist

**Contradiction:** Live weighted algorithm + cached snapshot.

**Resolution:**
```json
{
  "contradiction": "real-time-vs-cached-routing",
  "explanation": "performance-reliability-tradeoff",
  "primary": "live-weighted-algorithm",
  "fallback": "cached-snapshot",
  "database_health_check": {
    "healthy": "use_live_algorithm",
    "unhealthy": "use_cached_snapshot",
    "check_interval": "every-request"
  },
  "sla": {
    "live": "200ms-response-time",
    "cached": "10ms-response-time"
  }
}
```

---

## HOW REPLIT INTERPRETS THIS ARCHITECTURE

### 1. Service Health Monitoring

Replit reads your redundancy metadata and **automatically monitors both primary and fallback services**:

```javascript
// Replit monitors this:
{
  "service": "claim-audit",
  "primary": "healthy ✅",
  "fallback": "healthy ✅",
  "current": "primary (in-use)",
  "action": "none-needed"
}

// If primary fails:
{
  "service": "claim-audit",
  "primary": "failed ❌",
  "fallback": "healthy ✅",
  "current": "fallback (auto-switched)",
  "action": "alert-ops-to-fix-primary"
}
```

### 2. Auto-Failover Decisions

Replit uses your contradiction-resolution metadata to **automatically switch services**:

```javascript
// If OpenAI API fails:
if (primary.openai.status === 'failed') {
  // Replit checks YOUR metadata:
  // "falloverBehavior": "cascade-fallbacks"
  
  // So it automatically:
  switchTo(fallback.localAI);  // Try LocalAI
  
  // If that fails:
  if (fallback.localAI.status === 'failed') {
    switchTo(fallback.ruleBased);  // Try rules
  }
}
```

### 3. Resource Allocation

Replit can **optimize resource allocation** based on your redundancy definitions:

```javascript
// Replit sees:
// - Primary OCR: GPU-accelerated (expensive)
// - Fallback OCR: CPU-only (cheap)

// During low-traffic hours, Replit might:
// - Disable GPU allocation for Primary
// - Pre-warm Fallback in CPU (ready if needed)
// - Save compute cost while maintaining SLA

// During high-traffic hours:
// - Allocate full GPU to Primary
// - Keep Fallback warm but not running
```

### 4. Cost Optimization

Replit can **recommend cost optimizations** based on your redundancy:

```json
{
  "optimization": "optional-feature-suggests",
  "insight": "LLM-based audit has fallback (rule-based)",
  "finding": "85% of claims resolve with rule-based fallback",
  "recommendation": "Reduce OpenAI API quota, pre-route to fallback for non-complex claims",
  "potential_savings": "$500–$1000/month"
}
```

---

## REPLIT CONFIGURATION FILE

Create `.replit-redundancy.json` in your repo root:

```json
{
  "version": "1.0",
  "app": "MaxClaim v3.1",
  "redundancy_philosophy": "optional-redundancy-backup",
  "contradiction_resolution": "cascading-fallbacks",
  
  "services": {
    "claim-audit": {
      "primary": { "type": "ai-llm", "provider": "openai" },
      "fallback": { "type": "rule-engine", "provider": "local" },
      "behavior": "automatic-switchover"
    },
    "ocr-parsing": {
      "primary": { "type": "paddle-ocr", "resources": "gpu" },
      "fallback_chain": [
        { "type": "tesseract-js", "resources": "cpu" },
        { "type": "manual-entry", "resources": "user" }
      ],
      "behavior": "cascading-fallback"
    },
    "lead-routing": {
      "primary": { "type": "live-algorithm", "source": "database" },
      "fallback": { "type": "cached-snapshot", "source": "redis" },
      "behavior": "switchover-on-db-failure"
    },
    "payments": {
      "primary": { "type": "stripe-api" },
      "fallback": { "type": "local-queue" },
      "behavior": "queue-and-retry"
    },
    "authentication": {
      "primary": { "type": "clerk" },
      "fallback": { "type": "jwt-local" },
      "behavior": "provider-swap"
    }
  },

  "feature_toggles": {
    "advanced-analytics": {
      "deployed": true,
      "default": "disabled",
      "activation": "user-plan-and-service-health"
    },
    "multi-agent-swarm": {
      "deployed": true,
      "default": "disabled",
      "activation": "enterprise-tier-only"
    },
    "realtime-notifications": {
      "deployed": true,
      "default": "disabled",
      "activation": "browser-and-user-preference"
    }
  },

  "monitoring": {
    "check_interval": "10-seconds",
    "alert_on_failure": true,
    "auto_failover": true,
    "cost_optimization": true,
    "health_endpoints": {
      "primary-services": "/api/health/primary",
      "fallback-services": "/api/health/fallback",
      "features": "/api/health/features"
    }
  },

  "documentation": {
    "primary_guide": "ARCHITECTURE.md",
    "redundancy_guide": "REDUNDANCY.md",
    "failover_procedures": "FAILOVER.md",
    "contradiction_resolution": "CONTRADICTIONS.md"
  }
}
```

---

## ENVIRONMENT VARIABLE TOGGLES

In your `.env` file (for Replit to parse):

```bash
# PRIMARY SERVICE TOGGLES
ENABLE_PRIMARY_OPENAI_AUDIT=true
ENABLE_PRIMARY_PADDLE_OCR=true
ENABLE_PRIMARY_LIVE_ROUTING=true
ENABLE_PRIMARY_STRIPE=true

# FALLBACK SERVICE TOGGLES
ENABLE_FALLBACK_RULE_AUDIT=true
ENABLE_FALLBACK_TESSERACT_OCR=true
ENABLE_FALLBACK_CACHED_ROUTING=true
ENABLE_FALLBACK_LOCAL_QUEUE=true

# FEATURE TOGGLES
ENABLE_ADVANCED_ANALYTICS=false
ENABLE_MULTI_AGENT_SWARM=false
ENABLE_REALTIME_NOTIFICATIONS=false

# FAILOVER THRESHOLDS
OPENAI_TIMEOUT_MS=10000
PADDLE_OCR_TIMEOUT_MS=5000
DB_HEALTH_CHECK_INTERVAL_MS=5000
STRIPE_RETRY_BACKOFF_SECONDS=5,10,30,60

# COST OPTIMIZATION
OPTIMIZE_FOR_COST=false
PREFER_FALLBACK_WHEN_POSSIBLE=false
```

---

## IMPLEMENTATION CHECKLIST FOR REPLIT

- [ ] Create `.replit-redundancy.json` with full service matrix
- [ ] Add health check endpoints for all services
- [ ] Implement automatic failover logic (see code examples)
- [ ] Document each contradiction with resolution strategy
- [ ] Test all fallback paths (fire-drill exercises)
- [ ] Monitor fallback activation rates (when are they triggered?)
- [ ] Set up alerts for primary service failures
- [ ] Create runbooks for manual intervention
- [ ] Add cost tracking per service tier
- [ ] Document feature toggle activation conditions

---

## SUMMARY

**For Replit to properly understand MaxClaim's architecture:**

1. ✅ **Redundancy is intentional**, not a bug
2. ✅ **Contradictions are documented** as primary + fallback
3. ✅ **Fallover is automatic** based on service health
4. ✅ **Features are toggleable** (deployed but conditionally enabled)
5. ✅ **Configuration is explicit** (.replit-redundancy.json)
6. ✅ **Behavior is predictable** (cascade, swap, queue-retry, etc.)

**This ensures MaxClaim runs reliably on ReplitCore with:**
- No service completely fails (always has fallback)
- Graceful degradation (fast → slower, but functional)
- Cost optimization (use fallbacks when primary is expensive)
- Automatic recovery (Replit handles switchovers)

---

**Document Status:** FINAL - Production-Ready  
**Created:** January 13, 2026, 9:11 AM CST  
**Owner:** Nate Chacon, Royal RC Inc.  
**For:** Replit Infrastructure & Redundancy Understanding
